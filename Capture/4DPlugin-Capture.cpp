/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Capture.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Capture
 #	author : miyako
 #	2019/07/31
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Capture.h"

BOOL capture_isComReady = FALSE;

#if VERSIONWIN
HWND windowRefMdi = NULL;

void OnExit() {
	if (capture_isComReady) {
		CoUninitialize();
		capture_isComReady = FALSE;
	}
}

void OnStartup() {
    
	//COINIT_MULTITHREADED will fail in 4D plugin
	if (SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED))) {
		capture_isComReady = TRUE;
	}
    PA_ulong32 version = PA_Get4DVersion();
    
    if (version >= 16)
    {
        windowRefMdi = (HWND)PA_GetMainWindowHWND();
    }
    else
    {
        //the window class is the folder name of the application
        HWND mdi = NULL;
        wchar_t path[_MAX_PATH] = { 0 };
        wchar_t * applicationPath = wcscpy(path, (const wchar_t *)PA_GetApplicationFullPath().fString);
        //remove file name (4D.exe)
        PathRemoveFileSpec(path);
        //check instance as well, to be sure
        HINSTANCE h = (HINSTANCE)PA_Get4DHInstance();
        do {
            mdi = FindWindowEx(NULL, mdi, (LPCTSTR)path, NULL);
            if (mdi)
            {
                if (h == (HINSTANCE)GetWindowLongPtr(mdi, GWLP_HINSTANCE))
                {
                    break;
                }
            }
        } while (mdi);
        windowRefMdi = mdi;
    }

}
#endif

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
#if VERSIONWIN
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
#endif
			case kDeinitPlugin:
			case kServerDeinitPlugin:
				OnExit();
				break;
			// --- Capture
            
			case 1 :
				CAPTURE_DEVICE_Get_default(params);
				break;
			case 2 :
				CAPTURE_DEVICE_LIST(params);
				break;
			case 3 :
				CAPTURE_PREVIEW_SET_RECT(params);
				break;
			case 4 :
				CAPTURE_PREVIEW_SNAP(params);
				break;
			case 5 :
				CAPTURE_PREVIEW_CLEAR(params);
				break;
			case 6 :
				CAPTURE_PREVIEW_Get_window(params);
				break;
			case 7 :
				CAPTURE_PREVIEW_SET_WINDOW(params);
				break;
			case 8 :
				CAPTURE_PREVIEW_Get_visible(params);
				break;
			case 9 :
				CAPTURE_PREVIEW_SET_VISIBLE(params);
				break;
			case 10 :
				CAPTURE_PREVIEW_Create(params);
				break;
			case 11 :
				CAPTURE_PREVIEW_GET_RECT(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

typedef struct {
	IVideoWindow	*videoWindow;
	IMediaControl	*mediaControl;
	IGraphBuilder	*graphBuilder;
	IBaseFilter		*deviceFilter;
	IBaseFilter		*grabberFilter;
	ISampleGrabber	*sampleGrabber;
	PA_long32		windowRef;
}captureContext;

std::map<PA_long32, captureContext*> capture_previews;
std::map<PA_long32, CUTF16String> capture_devices;

std::mutex globalMutex;

#if VERSIONWIN

captureContext *capture_contextGet(PA_long32 i) {

	captureContext *context = NULL;

	std::map<PA_long32, captureContext*>::iterator pos = capture_previews.find(i);

	if (pos != capture_previews.end()) {
		context = pos->second;
	}

	return context;
}

void capture_contextDelete(PA_long32 i) {

	captureContext *context = NULL;

	std::lock_guard<std::mutex> lock(globalMutex);

	std::map<PA_long32, captureContext*>::iterator pos = capture_previews.find(i);

	if (pos != capture_previews.end()) {

		context = pos->second;

		context->videoWindow->Release();
		context->mediaControl->Release();
		context->sampleGrabber->Release();
		context->grabberFilter->Release();
		context->graphBuilder->Release();
		context->deviceFilter->Release();

		delete context;

		capture_previews.erase(pos);

		std::map<PA_long32, CUTF16String>::iterator pos = capture_devices.find(i);
		if (pos != capture_devices.end())
			capture_devices.erase(pos);
	}

}

IBaseFilter *capture_getDeviceForName(C_TEXT &name)
{
	IBaseFilter *pBFilter = NULL;

	if (capture_isComReady)
	{
		ICreateDevEnum *pDevEnum = NULL;
		HRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_PPV_ARGS(&pDevEnum));

		CUTF16String n;
		name.copyUTF16String(&n);

		if (SUCCEEDED(hr))
		{
			IEnumMoniker *pEnum = NULL;
			hr = pDevEnum->CreateClassEnumerator(CLSID_VideoInputDeviceCategory, &pEnum, 0);

			if (hr != S_FALSE)
			{
				IMoniker *pMoniker = NULL;
				while (pEnum->Next(1, &pMoniker, NULL) == S_OK)
				{
					IPropertyBag *pPropBag = NULL;
					hr = pMoniker->BindToStorage(0, 0, IID_PPV_ARGS(&pPropBag));

					if (FAILED(hr))
					{
						pMoniker->Release();
						continue;
					}

					VARIANT var;
					VariantInit(&var);

					CUTF16String description;

					hr = pPropBag->Read(L"FriendlyName", &var, 0);

					if (SUCCEEDED(hr))
					{
						description = (const PA_Unichar *)var.bstrVal;
						VariantClear(&var);

						if (n.compare(description) == 0)
						{
							hr = pMoniker->BindToObject(0, 0, IID_IBaseFilter, (void **)&pBFilter);
						}

					}

					pPropBag->Release();
					pMoniker->Release();
				}

			}
			pDevEnum->Release();
		}

	}
	return pBFilter;
}

captureContext *capture_contextCreate(C_TEXT &device, PA_long32 *preview) {

	captureContext *context = NULL;

	if (capture_isComReady)
	{
		CUTF16String deviceName;
		device.copyUTF16String(&deviceName);

		BOOL _isAlreadyUsed = FALSE;

		std::lock_guard<std::mutex> lock(globalMutex);

		for (std::map<PA_long32, CUTF16String>::iterator it = capture_devices.begin(); it != capture_devices.end(); ++it) {
			if (it->second.compare(deviceName) == 0) {
				_isAlreadyUsed = TRUE;
				*preview = it->first;
				context = capture_contextGet(*preview);
				break;
			}
		}

		if (!_isAlreadyUsed) {
			IBaseFilter *pDeviceFilter = capture_getDeviceForName(device);
			if (pDeviceFilter)
			{
				IGraphBuilder *pGraph = NULL;
				HRESULT hr = CoCreateInstance(CLSID_FilterGraph, NULL,
					CLSCTX_INPROC_SERVER,
					IID_IGraphBuilder,
					(void **)&pGraph);
				if (SUCCEEDED(hr)) {
					ICaptureGraphBuilder2 *pCapture = NULL;
					hr = CoCreateInstance(CLSID_CaptureGraphBuilder2,
						NULL,
						CLSCTX_INPROC_SERVER,
						IID_ICaptureGraphBuilder2,
						(void**)&pCapture);

					if (SUCCEEDED(hr)) {
						IBaseFilter *pGrabberFilter = NULL;
						hr = CoCreateInstance(CLSID_SampleGrabber,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_PPV_ARGS(&pGrabberFilter));
						if (SUCCEEDED(hr)) {
							ISampleGrabber *pGrabber = NULL;
							hr = pGrabberFilter->QueryInterface(IID_ISampleGrabber, (void **)&pGrabber);
							if (SUCCEEDED(hr)) {
								//Set the Media Type
								AM_MEDIA_TYPE mt;
								ZeroMemory(&mt, sizeof(mt));
								mt.majortype = MEDIATYPE_Video;
								mt.subtype = MEDIASUBTYPE_RGB24;
								mt.formattype = FORMAT_VideoInfo;
								hr = pGrabber->SetMediaType(&mt);
								if (SUCCEEDED(hr)) {
									hr = pGraph->AddFilter(pGrabberFilter, L"Sample Grabber");
									if (SUCCEEDED(hr)) {
										hr = pCapture->SetFiltergraph(pGraph);
										if (SUCCEEDED(hr)) {
											IMediaControl *pMControl = NULL;
											hr = pGraph->QueryInterface(IID_IMediaControl, (void **)&pMControl);
											if (SUCCEEDED(hr)) {
												hr = pGraph->AddFilter(pDeviceFilter, L"Device Filter");
												if (SUCCEEDED(hr)) {
													hr = pCapture->RenderStream(&PIN_CATEGORY_PREVIEW,
														NULL,
														pDeviceFilter,
														pGrabberFilter,
														NULL);
													if (SUCCEEDED(hr)) {
														IVideoWindow *pVWindow = NULL;
														hr = pGraph->QueryInterface(IID_IVideoWindow, (void **)&pVWindow);
														if (SUCCEEDED(hr)) {

															pVWindow->put_Visible(OAFALSE);
															pVWindow->put_AutoShow(OAFALSE);
															pVWindow->SetWindowPosition(0, 0, 0, 0);
															pVWindow->HideCursor(OAFALSE);
															pVWindow->put_WindowStyle(WS_CHILD | WS_CLIPCHILDREN);

															unsigned int i = 1;

															while (capture_previews.find(i) != capture_previews.end()) {
																i++;
															}

															context = new(captureContext);

															context->mediaControl = pMControl;
															context->videoWindow = pVWindow;
															context->graphBuilder = pGraph;
															context->deviceFilter = pDeviceFilter;
															context->grabberFilter = pGrabberFilter;
															context->sampleGrabber = pGrabber;

															capture_previews.insert(std::map<PA_long32, captureContext*>::value_type(i, context));
															capture_devices.insert(std::map<PA_long32, CUTF16String>::value_type(i, deviceName));

															*preview = i;

															context->mediaControl->Pause();
															context->sampleGrabber->SetBufferSamples(FALSE);

														}//pVWindow
													}//RenderStream
												}//AddFilter
											}//pMControl
										}//SetFiltergraph
									}//AddFilter
								}//SetMediaType
							}//pGrabber
						}//pGrabberFilter
						pCapture->Release();
					}//pCapture
				}//pGraph
			}//pDeviceFilter
		}
	}
	return context;
}

void capture_getDevicesList(ARRAY_TEXT &names)
{

	names.setSize(0);
	names.setSize(1);

	if (capture_isComReady)
	{
		ICreateDevEnum *pDevEnum = NULL;
		HRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_PPV_ARGS(&pDevEnum));

		if (SUCCEEDED(hr))
		{
			IEnumMoniker *pEnum = NULL;
			hr = pDevEnum->CreateClassEnumerator(CLSID_VideoInputDeviceCategory, &pEnum, 0);

			if (hr != S_FALSE)
			{
				IMoniker *pMoniker = NULL;
				while (pEnum->Next(1, &pMoniker, NULL) == S_OK)
				{
					IPropertyBag *pPropBag = NULL;
					hr = pMoniker->BindToStorage(0, 0, IID_PPV_ARGS(&pPropBag));

					if (FAILED(hr))
					{
						pMoniker->Release();
						continue;
					}

					VARIANT var;
					VariantInit(&var);

					CUTF16String name;

					hr = pPropBag->Read(L"FriendlyName", &var, 0);

					if (SUCCEEDED(hr))
					{
						name = (const PA_Unichar *)var.bstrVal;
						VariantClear(&var);
						names.appendUTF16String(&name);
					}

					pPropBag->Release();
					pMoniker->Release();
				}

			}
			pDevEnum->Release();
		}
	}
}

void capture_getDefaultDevice(C_TEXT &name)
{
	ARRAY_TEXT names;

	capture_getDevicesList(names);

	if (names.getSize() > 1) {
		CUTF16String n;
		names.copyUTF16StringAtIndex(&n, 1);
		name.setUTF16String(&n);
	}
	else {
		name.setUTF16String((const PA_Unichar *)L"", 0);
	}
}

void capture_getRect(PA_long32 paramPreview, PA_long32* paramX, PA_long32 *paramY, PA_long32 *paramW, PA_long32 *paramH)
{
	captureContext *context = capture_contextGet(paramPreview);

	if (context) {

		long x = 0, y = 0, w = 0, h = 0;

		if (S_OK == context->videoWindow->GetWindowPosition(&x, &y, &w, &h)) {
			*paramX =x;
			*paramY =y;
			*paramW =w;
			*paramH =h;
		}
	}
}

void capture_setRect(PA_long32 paramPreview, PA_long32 paramX, PA_long32 paramY, PA_long32 paramW, PA_long32 paramH)
{
	captureContext *context = capture_contextGet(paramPreview);

	if (context) {

		long x = 0, y = 0, w = 0, h = 0;

		context->videoWindow->SetWindowPosition(
			paramX,
			paramY,
			paramW,
			paramH);
	}
}

void capture_getVisible(PA_long32 paramPreview, PA_long32 *paramVisible)
{
	captureContext *context = capture_contextGet(paramPreview);

	if (context) {

		long v = 0;

		if (S_OK == context->videoWindow->get_Visible(&v)) {
			*paramVisible =v;
		}
	}
}

void capture_setVisible(PA_long32 paramPreview, PA_long32 paramVisible)
{
	captureContext *context = capture_contextGet(paramPreview);

	if (context) {
		if (paramVisible) {
			context->sampleGrabber->SetBufferSamples(TRUE);
			context->videoWindow->put_Visible(OATRUE);
			context->videoWindow->put_AutoShow(OATRUE);
			context->mediaControl->Run();
		}
		else {
			context->sampleGrabber->SetBufferSamples(FALSE);
			context->videoWindow->put_Visible(OAFALSE);
			context->videoWindow->put_AutoShow(OAFALSE);
			context->mediaControl->Pause();
		}
	}
}

PA_long32 capture_getWindow(PA_long32 paramPreview)
{
	PA_long32 paramWindow = 0;

	captureContext *context = capture_contextGet(paramPreview);

	if (context) {

		OAHWND owner = 0;

		if (S_OK == context->videoWindow->get_Owner(&owner)) {
			paramWindow = context->windowRef;
		}
	}

	return paramWindow;
}

void capture_setWindow(PA_long32 paramPreview, PA_long32 paramWindow)
{
	PA_WindowRef window = reinterpret_cast<PA_WindowRef>(paramWindow);

	HWND windowRef = (HWND)PA_GetHWND(window);
	if (!window)
	{
		windowRef = windowRefMdi;
	}

	captureContext *context = capture_contextGet(paramPreview);

	if (context) {
		context->windowRef = paramWindow;
		context->videoWindow->put_Owner((OAHWND)windowRef);
	}
}

void capture_getFullscreen(PA_long32 paramPreview, PA_long32 *fullScreen)
{
	captureContext *context = capture_contextGet(paramPreview);

	if (context) {

		long f = 0;

		if (S_OK == context->videoWindow->get_FullScreenMode(&f)) {
			*fullScreen = f;
		}
	}
}

void capture_setFullscreen(PA_long32 paramPreview, PA_long32 *fullScreen)
{
	captureContext *context = capture_contextGet(paramPreview);

	if (context) {
		if (*fullScreen) {
			context->videoWindow->put_FullScreenMode(OATRUE);
		}
		else {
			context->videoWindow->put_FullScreenMode(OAFALSE);
		}
	}
}

void CAPTURE_DEVICE_Get_default(PA_PluginParameters params) {

	C_TEXT returnValue;

	capture_getDefaultDevice(returnValue);

	PA_ReturnString(params, (PA_Unichar *)returnValue.getUTF16StringPtr());
}

void CAPTURE_DEVICE_LIST(PA_PluginParameters params) {

	ARRAY_TEXT names;

	capture_getDevicesList(names);

	names.toParamAtIndex((PackagePtr)params->fParameters, 1);
}

void CAPTURE_PREVIEW_SET_RECT(PA_PluginParameters params) {

	PA_long32 c = PA_GetLongParameter(params, 1);
	PA_long32 x = PA_GetLongParameter(params, 2);
	PA_long32 y = PA_GetLongParameter(params, 3);
	PA_long32 w = PA_GetLongParameter(params, 4);
	PA_long32 h = PA_GetLongParameter(params, 5);

	capture_setRect(c, x, y, w, h);
}

void CAPTURE_PREVIEW_SNAP(PA_PluginParameters params) {

	PA_long32 c = PA_GetLongParameter(params, 1);

	captureContext *context = capture_contextGet(c);

	if (context) {

		IGraphBuilder *pGraph = context->graphBuilder;
		IMediaControl *pControl = context->mediaControl;
		IBaseFilter *pDeviceFilter = context->deviceFilter;
		IBaseFilter *pGrabberFilter = context->grabberFilter;
		ISampleGrabber *pSampleGrabber = context->sampleGrabber;

		AM_MEDIA_TYPE am_media_type;
		ZeroMemory(&am_media_type, sizeof(am_media_type));

		pSampleGrabber->GetConnectedMediaType(&am_media_type);

		VIDEOINFOHEADER *pVideoInfoHeader = (VIDEOINFOHEADER *)am_media_type.pbFormat;

		long size = am_media_type.lSampleSize;
		std::vector<uint8_t> buf(size);

		pSampleGrabber->GetCurrentBuffer(&size, (long *)&buf[0]);

		BITMAPFILEHEADER bmphdr;
		memset(&bmphdr, 0, sizeof(bmphdr));
		bmphdr.bfType = ('M' << 8) | 'B';
		bmphdr.bfSize = sizeof(bmphdr) + sizeof(BITMAPINFOHEADER) + size;
		bmphdr.bfOffBits = sizeof(bmphdr) + sizeof(BITMAPINFOHEADER);

		std::vector<uint8_t> bytes(sizeof(bmphdr) + sizeof(BITMAPINFOHEADER) + size);
		memmove((char *)&bytes[0], &bmphdr, sizeof(bmphdr));
		memmove((char *)&bytes[sizeof(bmphdr)], &pVideoInfoHeader->bmiHeader, sizeof(BITMAPINFOHEADER));
		memmove((char *)&bytes[sizeof(bmphdr) + sizeof(BITMAPINFOHEADER)], &buf[0], size);

		PA_Picture p;
		p = PA_CreatePicture(&bytes[0], bytes.size());
		PA_SetPictureParameter(params, 2, p);
	}


}

void CAPTURE_PREVIEW_CLEAR(PA_PluginParameters params) {

	PA_long32 c = PA_GetLongParameter(params, 1);

	capture_contextDelete(c);
}

void CAPTURE_PREVIEW_Get_visible(PA_PluginParameters params) {

	PA_long32 c = PA_GetLongParameter(params, 1);
	PA_long32 v;

	capture_getVisible(c, &v);

	capture_contextGet(c);

	PA_ReturnLong(params, v);
}

void CAPTURE_PREVIEW_SET_VISIBLE(PA_PluginParameters params) {

	PA_long32 c = PA_GetLongParameter(params, 1);
	PA_long32 v = PA_GetLongParameter(params, 2);

	capture_setVisible(c, v);
}

void CAPTURE_PREVIEW_Create(PA_PluginParameters params) {

	C_TEXT paramDevice;
	PA_long32 c;

	paramDevice.setUTF16String(PA_GetStringParameter(params, 1));
	capture_contextCreate(paramDevice, &c);

	PA_ReturnLong(params, c);
}

void CAPTURE_PREVIEW_GET_RECT(PA_PluginParameters params) {

	PA_long32 c = PA_GetLongParameter(params, 1);
	PA_long32 x = PA_GetLongParameter(params, 2);
	PA_long32 y = PA_GetLongParameter(params, 3);
	PA_long32 w = PA_GetLongParameter(params, 4);
	PA_long32 h = PA_GetLongParameter(params, 5);

	capture_getRect(c, &x, &y, &w, &h);

	PA_SetLongParameter(params, 2, x);
	PA_SetLongParameter(params, 3, y);
	PA_SetLongParameter(params, 4, w);
	PA_SetLongParameter(params, 5, h);
}

void CAPTURE_PREVIEW_SET_WINDOW(PA_PluginParameters params) {

	PA_long32 c = PA_GetLongParameter(params, 1);
	PA_long32 w = PA_GetLongParameter(params, 2);

	capture_setWindow(c, w);
}

void CAPTURE_PREVIEW_Get_window(PA_PluginParameters params) {

	PA_long32 c = PA_GetLongParameter(params, 1);
	PA_long32 w = capture_getWindow(c);

	PA_ReturnLong(params, w);
}

#endif
